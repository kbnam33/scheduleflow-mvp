// server/src/routes/auth.js
const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const supabase = require('../config/supabase');
const logger = require('../utils/logger');
const UserPreferences = require('../models/UserPreferences'); // To create default preferences

const router = express.Router();

if (!process.env.JWT_SECRET) {
  logger.error('FATAL ERROR: JWT_SECRET is not defined in environment variables. Auth routes will not work.');
  // Potentially throw an error or exit if JWT_SECRET is critical for server startup
}

// POST /api/auth/signup
router.post('/signup', async (req, res) => {
  const { email, password, fullName, role: userRole } = req.body; // Added fullName and role from onboarding

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  try {
    // Check if user already exists
    const { data: existingUser, error: selectError } = await supabase
      .from('users')
      .select('email')
      .eq('email', email.toLowerCase())
      .single();

    if (selectError && selectError.code !== 'PGRST116') { // PGRST116: No rows found, which is good here
      logger.error('Error checking for existing user', { code: selectError.code, message: selectError.message });
      return res.status(500).json({ error: 'Error checking user existence' });
    }

    if (existingUser) {
      return res.status(400).json({ error: 'User with this email already exists' });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(password, salt);

    // Create user in 'users' table
    const { data: newUser, error: insertError } = await supabase
      .from('users')
      .insert({ 
        email: email.toLowerCase(), 
        password_hash,
        full_name: fullName, // From onboarding context
        role: userRole // From onboarding context
        // id will be auto-generated by Supabase (uuid_generate_v4())
      })
      .select()
      .single();

    if (insertError) {
      logger.error('Error creating user', { code: insertError.code, message: insertError.message });
      return res.status(500).json({ error: 'Failed to create user' });
    }

    if (!newUser || !newUser.id) {
        logger.error('User created but ID not returned', { newUser });
        return res.status(500).json({ error: 'Failed to retrieve new user ID after creation' });
    }

    // Create default user preferences
    try {
        await UserPreferences.updatePreferences(newUser.id, {
            work_hours: UserPreferences.getDefaultWorkHours(),
            notification_preferences: UserPreferences.getDefaultNotificationPreferences(),
            focus_time_preferences: UserPreferences.getDefaultFocusTimePreferences(),
            theme: 'dark' // Default theme
        });
        logger.info('Default preferences created for new user', { userId: newUser.id });
    } catch (prefError) {
        logger.error('Failed to create default preferences for user', { userId: newUser.id, error: prefError.message });
        // Non-fatal for signup, but log it. User can set prefs later.
    }


    // Generate JWT
    const payload = {
      user: {
        id: newUser.id,
        email: newUser.email,
        role: newUser.role // Include role if it exists
      },
    };

    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '7d' }); // Token expires in 7 days

    res.status(201).json({ token, userId: newUser.id, email: newUser.email });

  } catch (error) {
    logger.error('Signup error', { message: error.message, stack: error.stack });
    res.status(500).json({ error: 'Server error during signup' });
  }
});

module.exports = router;